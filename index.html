<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fishbone Pro - Editor Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @media print {
            body { background-color: white; }
            .print\:hidden { display: none !important; }
            .print\:p-0 { padding: 0 !important; }
            .print\:shadow-none { box-shadow: none !important; }
            .print\:border-none { border: none !important; }
            .print\:bg-white { background-color: white !important; }
        }
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useRef, useEffect } = React;

        // --- Icons ---
        const Plus = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>;
        const Trash2 = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
        const Save = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>;
        const FolderOpen = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>;
        const Printer = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>;
        const Maximize = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>;
        const FileText = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>;
        const Type = ({size=20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="4 7 4 4 20 4 20 7"/><line x1="9" y1="20" x2="15" y2="20"/><line x1="12" y1="4" x2="12" y2="20"/></svg>;
        const Star = ({size=16, filled=false}) => <svg width={size} height={size} viewBox="0 0 24 24" fill={filled ? "#ea580c" : "none"} stroke={filled ? "#ea580c" : "currentColor"} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>;
        const Check = ({size=16}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12"/></svg>;

        // --- Config ---
        const LOCAL_STORAGE_KEY = 'fishbone_pro_data_v1';

        const STATUS_OPTIONS = {
            CANT_EXECUTE: { id: 'CANT_EXECUTE', label: '⛔ Can\'t Execute', icon: '⛔', color: '#94a3b8', boneColor: '#94a3b8', bg: 'bg-gray-100 text-gray-500' },
            ON_GOING: { id: 'ON_GOING', label: '⏳ On Going', icon: '⏳', color: '#3b82f6', boneColor: '#60a5fa', bg: 'bg-blue-50 text-blue-700' },
            FINISHED: { id: 'FINISHED', label: '✅ Finished', icon: '✅', color: '#16a34a', boneColor: '#22c55e', bg: 'bg-green-50 text-green-700' },
            EXCLUDE: { id: 'EXCLUDE', label: '❌ Exclude', icon: '❌', color: '#cbd5e1', boneColor: '#94a3b8', bg: 'bg-gray-50 text-gray-400 line-through' }
        };

        const DEMO_DATA = [
            { id: 1, category: "能源/電力", cause: "點火系統供電", factor: "電池沒電 (更換測試)", method: "更換全新電池", evidence: "成功點燃", status: 'FINISHED', isPriority: true },
            { id: 2, category: "能源/電力", cause: "點火系統供電", factor: "電池盒彈簧嚴重鏽蝕", method: "目視檢查", evidence: "正常", status: 'EXCLUDE', isPriority: false },
            { id: 21, category: "能源/電力", cause: "點火系統供電", factor: "電池接點接觸不良", method: "清潔接點", evidence: "無效", status: 'EXCLUDE', isPriority: false },
            { id: 3, category: "能源/電力", cause: "瓦斯供應異常", factor: "瓦斯桶沒氣", method: "搖晃確認", evidence: "有氣", status: 'EXCLUDE', isPriority: false },
            { id: 4, category: "設備硬體", cause: "點火針故障", factor: "點火針積碳", method: "清潔測試", evidence: "無效", status: 'CANT_EXECUTE', isPriority: false },
            { id: 5, category: "設備硬體", cause: "水盤異常", factor: "皮膜破裂", method: "拆機", evidence: "待確認", status: 'ON_GOING', isPriority: true },
            { id: 6, category: "人為操作", cause: "模式設定錯誤", factor: "誤切到夏天模式", method: "檢查面板", evidence: "正常", status: 'EXCLUDE', isPriority: false },
        ];

        const getTextWidth = (text, fontSize = 12) => {
            const canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
            const context = canvas.getContext("2d");
            context.font = `bold ${fontSize}px system-ui`;
            const metrics = context.measureText(text || "");
            return metrics.width + 10;
        };

        // --- HoverExpandTextarea ---
        const HoverTextarea = ({ value, onChange, placeholder }) => {
            const [isExpanded, setIsExpanded] = useState(false);
            const ref = useRef(null);

            useEffect(() => {
                const el = ref.current;
                if (el) {
                    if (isExpanded) {
                        el.style.height = 'auto';
                        el.style.height = `${el.scrollHeight + 2}px`;
                        el.style.width = 'auto';
                        el.style.minWidth = '100%';
                    } else {
                        el.style.height = '100%';
                        el.style.width = '100%';
                    }
                }
            }, [value, isExpanded]);

            return (
                <div className="relative h-12 w-full">
                    <textarea
                        ref={ref}
                        value={value}
                        onChange={onChange}
                        onMouseEnter={() => setIsExpanded(true)}
                        onMouseLeave={() => { if (document.activeElement !== ref.current) setIsExpanded(false); }}
                        onFocus={() => setIsExpanded(true)}
                        onBlur={() => setIsExpanded(false)}
                        placeholder={placeholder}
                        className={`
                            w-full resize-none outline-none px-2 py-1.5 text-sm rounded transition-all duration-150
                            ${isExpanded 
                                ? 'absolute top-0 left-0 z-50 bg-white shadow-xl border border-blue-300 min-h-[48px]' 
                                : 'bg-transparent border-b border-transparent h-full overflow-hidden text-slate-600'
                            }
                        `}
                        rows={1}
                    />
                </div>
            );
        };

        // --- FIXED RichTextEditor ---
        const RichTextEditor = ({ value, onChange }) => {
            const editorRef = useRef(null);
            
            useEffect(() => {
                // IMPORTANT: Fix for cursor jumping
                // Only update innerHTML if the element is NOT focused by the user (e.g. initial load or file open)
                // OR if the value difference is huge (meaning a complete replacement happened)
                if (editorRef.current) {
                    const isActive = document.activeElement === editorRef.current;
                    const currentHTML = editorRef.current.innerHTML;
                    
                    // If not focused, or if contents are vastly different (e.g. file load), update DOM.
                    // If focused and contents are similar, assume user is typing and DO NOT update DOM (preserves cursor).
                    if (!isActive || Math.abs(currentHTML.length - value.length) > 10) {
                        if (currentHTML !== value) {
                            editorRef.current.innerHTML = value;
                        }
                    }
                }
            }, [value]);

            const handleInput = () => {
                if (editorRef.current) {
                    onChange(editorRef.current.innerHTML);
                }
            };

            const exec = (cmd, val) => { document.execCommand(cmd, false, val); editorRef.current?.focus(); };
            
            const handlePaste = (e) => {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") !== -1) {
                        e.preventDefault();
                        const blob = items[i].getAsFile();
                        if (blob) {
                            const reader = new FileReader();
                            reader.onload = (ev) => {
                                document.execCommand('insertHTML', false, `<img src="${ev.target?.result}" style="max-width:100%; border-radius: 8px; margin: 10px 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1);" />`);
                                handleInput();
                            };
                            reader.readAsDataURL(blob);
                        }
                    }
                }
            };

            return (
                <div className="w-full bg-white rounded-xl shadow-sm border border-slate-200 overflow-hidden mt-6 print:border-none print:shadow-none">
                    <div className="bg-slate-50 border-b border-slate-200 px-3 py-2 flex items-center gap-2 print:hidden">
                        <span className="text-xs font-bold text-slate-400 mr-2 uppercase">Project Notes</span>
                        <button onClick={() => exec('bold')} className="p-1 hover:bg-white rounded font-bold border border-transparent">B</button>
                        <button onClick={() => exec('italic')} className="p-1 hover:bg-white rounded italic border border-transparent">I</button>
                        <button onClick={() => exec('foreColor', '#ef4444')} className="w-4 h-4 rounded-full bg-red-500"></button>
                        <button onClick={() => exec('foreColor', '#3b82f6')} className="w-4 h-4 rounded-full bg-blue-500"></button>
                    </div>
                    {/* REMOVED dangerouslySetInnerHTML to prevent React from re-rendering the DOM on every keystroke */}
                    <div 
                        ref={editorRef} 
                        contentEditable 
                        className="p-6 min-h-[150px] outline-none text-slate-700 text-sm print:p-0" 
                        onInput={handleInput} 
                        onPaste={handlePaste} 
                    />
                </div>
            );
        };

        const App = () => {
            const [problem, setProblem] = useState("熱水器不熱");
            const [problemDesc, setProblemDesc] = useState("熱水器完全沒有反應，有更換過電池");
            const [rows, setRows] = useState(DEMO_DATA);
            const [notes, setNotes] = useState("<div>Notes...</div>");
            const [scale, setScale] = useState(1);
            const [baseFontSize, setBaseFontSize] = useState(14); 
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [isAutoSaved, setIsAutoSaved] = useState(false); 
            
            const fileInputRef = useRef(null);
            const canvasRef = useRef(null);

            useEffect(() => {
                try {
                    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (savedData) {
                        const parsed = JSON.parse(savedData);
                        if(parsed.problem) setProblem(parsed.problem);
                        if(parsed.problemDesc) setProblemDesc(parsed.problemDesc);
                        if(parsed.rows) setRows(parsed.rows);
                        if(parsed.notes) setNotes(parsed.notes);
                        if(parsed.baseFontSize) setBaseFontSize(parsed.baseFontSize);
                    }
                } catch (e) {}
            }, []);

            useEffect(() => {
                const timeoutId = setTimeout(() => {
                    try {
                        const dataToSave = { problem, problemDesc, rows, notes, baseFontSize, timestamp: Date.now() };
                        localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
                        setIsAutoSaved(true);
                        setTimeout(() => setIsAutoSaved(false), 3000);
                    } catch (e) {}
                }, 800);
                return () => clearTimeout(timeoutId);
            }, [problem, problemDesc, rows, notes, baseFontSize]);

            const handleRowChange = (id, field, value) => setRows(rows.map(r => r.id === id ? { ...r, [field]: value } : r));
            const insertRowAfter = (index) => {
                const currentRow = rows[index];
                const newId = rows.length > 0 ? Math.max(...rows.map(r => r.id)) + 1 : 1;
                const newRows = [...rows];
                newRows.splice(index + 1, 0, { ...currentRow, id: newId, factor: "New Factor", method: "", evidence: "", status: 'ON_GOING', isPriority: false });
                setRows(newRows);
            };
            const deleteRow = (id) => setRows(rows.filter(r => r.id !== id));
            const addFirstRow = () => setRows([{ id: 1, category: "Primary", cause: "Secondary", factor: "Factor", method: "", evidence: "", status: 'ON_GOING', isPriority: false }]);
            const clearData = () => { 
                if(confirm("Are you sure you want to clear all data?")) { 
                    setRows([]); setNotes(""); setProblem("Main Problem"); setProblemDesc("");
                    try { localStorage.removeItem(LOCAL_STORAGE_KEY); } catch(e) {}
                }
            };
            const handleSave = () => {
                const blob = new Blob([JSON.stringify({ problem, problemDesc, rows, notes, version: "3.7-VisualTweaks" }, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const link = document.createElement("a");
                link.href = url;
                link.download = `RCA_${problem.replace(/[^a-z0-9]/gi, '_').substring(0, 20)}.json`;
                link.click();
            };
            const handleLoad = (e) => {
                const file = e.target.files?.[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target?.result);
                        if(data.problem) setProblem(data.problem);
                        if(data.problemDesc) setProblemDesc(data.problemDesc);
                        if(data.rows) setRows(data.rows);
                        if(data.notes) setNotes(data.notes);
                    } catch (err) { alert("Invalid file"); }
                };
                reader.readAsText(file);
                e.target.value = '';
            };
            const handlePrint = () => { setScale(0.85); setPan({x:0, y:0}); setTimeout(() => window.print(), 100); };

            const fishboneStructure = useMemo(() => {
                const catGroups = {};
                rows.forEach(row => {
                    const cat = row.category || "Uncategorized";
                    if (!catGroups[cat]) catGroups[cat] = [];
                    catGroups[cat].push(row);
                });
                return Object.entries(catGroups).map(([catName, catRows]) => {
                    const causeGroups = {};
                    catRows.forEach(row => {
                        const cause = row.cause || "Unspecified";
                        if (!causeGroups[cause]) causeGroups[cause] = [];
                        causeGroups[cause].push(row);
                    });
                    return { name: catName, causes: Object.entries(causeGroups).map(([causeName, factors]) => ({ name: causeName, factors: factors })) };
                });
            }, [rows]);

            const layoutConfig = useMemo(() => {
                const fontGrowth = Math.max(0, baseFontSize - 14);
                const s = 1 + (fontGrowth * 0.01); 
                return {
                    s,
                    fontSize: baseFontSize,
                    smallFontSize: Math.max(10, baseFontSize - 2),
                    categorySpacing: 350 + (fontGrowth * 6),
                    factorSpacing: 25 + (fontGrowth * 0.5), 
                    minBoneLength: 220 + (fontGrowth * 2),
                    verticalBranchGap: 130 + (fontGrowth * 3.5),
                    problemFontSize: 24, 
                    headScale: 1.0 
                };
            }, [baseFontSize]);

            // --- REFACTORED GEOMETRY CALCULATION WITH AUTO-HEIGHT ---
            const { elements: fishboneElements, totalWidth, totalHeight, viewportY } = useMemo(() => {
                const { s, fontSize, smallFontSize, categorySpacing, verticalBranchGap, problemFontSize, headScale } = layoutConfig;

                // 1. First Pass: Calculate Structure & Max Heights
                let maxTopHeight = 0;
                let maxBottomHeight = 0;

                const categoriesWithLayout = fishboneStructure.map((cat, index) => {
                    const isTop = index % 2 === 0;
                    // Calculate bone length needed for this category
                    let totalSpacingNeeded = cat.causes.length * verticalBranchGap + (100 * s);
                    const boneLength = Math.max(layoutConfig.minBoneLength, totalSpacingNeeded);
                    
                    if (isTop) maxTopHeight = Math.max(maxTopHeight, boneLength);
                    else maxBottomHeight = Math.max(maxBottomHeight, boneLength);

                    const causesWithLayout = cat.causes.map(cause => {
                        let currentPos = 40 * s;
                        const factorsWithPos = cause.factors.map((f, i) => {
                            const statusConfig = STATUS_OPTIONS[f.status] || STATUS_OPTIONS.ON_GOING;
                            const prefix = statusConfig.icon + " ";
                            const fullText = prefix + f.factor + (f.isPriority ? " ⭐" : "");
                            const width = getTextWidth(fullText, smallFontSize);
                            const step = width * 0.7 + (15 * s); 
                            const pos = currentPos;
                            currentPos += step; 
                            return { ...f, xOffset: pos, width, statusIcon: statusConfig.icon };
                        });
                        const totalLen = currentPos + (40 * s); 
                        const causeTextW = getTextWidth(cause.name, fontSize);
                        const finalLen = Math.max(totalLen, causeTextW + (60 * s));
                        return { ...cause, factors: factorsWithPos, totalLen: finalLen };
                    });
                    return { ...cat, causes: causesWithLayout, boneLength, isTop };
                });

                // 2. Determine Dynamic Spine Y and Canvas Height
                const verticalPadding = 150; // Padding for text above/below bones
                const dynamicSpineY = maxTopHeight + verticalPadding;
                const dynamicTotalHeight = dynamicSpineY + maxBottomHeight + verticalPadding;

                // 3. Determine Head Position & Auto-Shift
                let maxCauseLenInFirstCat = 0;
                if (categoriesWithLayout.length > 0) {
                    categoriesWithLayout[0].causes.forEach(c => {
                        if (c.totalLen > maxCauseLenInFirstCat) maxCauseLenInFirstCat = c.totalLen;
                    });
                }
                const headGap = Math.max(260 * s, maxCauseLenInFirstCat + 80);
                const rawDynamicHeadX = Math.max(
                    1200 - 250, 
                    200 + categoriesWithLayout.length * categorySpacing
                );

                const leftmostBoneRawX = rawDynamicHeadX - headGap - ((categoriesWithLayout.length - 1) * categorySpacing);
                const safeLeftMargin = 200;
                let shiftRight = 0;
                if (leftmostBoneRawX < safeLeftMargin) {
                    shiftRight = safeLeftMargin - leftmostBoneRawX;
                }

                const dynamicHeadX = rawDynamicHeadX + shiftRight;
                const firstBoneX = dynamicHeadX - headGap;
                const lastBoneX = firstBoneX - ((categoriesWithLayout.length - 1) * categorySpacing);
                const finalSpineStart = lastBoneX - 100; 

                const headW = 240 * headScale;
                const headH = 90 * headScale;
                const requiredWidth = dynamicHeadX + headW + 250; // Increased right padding

                // 4. Render
                const elements = [];
                const spineY = dynamicSpineY; // Use dynamic Y

                elements.push(<path key="tail" d={`M ${finalSpineStart} ${spineY} L ${finalSpineStart - 60} ${spineY - 50} Q ${finalSpineStart - 40} ${spineY} ${finalSpineStart - 60} ${spineY + 50} Z`} fill="#3b82f6" opacity="0.8" />);
                elements.push(<line key="spine" x1={finalSpineStart} y1={spineY} x2={dynamicHeadX} y2={spineY} stroke="#475569" strokeWidth={6 * s} strokeLinecap="round" />);
                
                elements.push(
                    <g key="head">
                        <path d={`M ${dynamicHeadX} ${spineY - headH} L ${dynamicHeadX + headW} ${spineY} L ${dynamicHeadX} ${spineY + headH} Q ${dynamicHeadX - 40} ${spineY} ${dynamicHeadX} ${spineY - headH} Z`} fill="#3b82f6" className="drop-shadow-xl" />
                        <circle cx={dynamicHeadX + (headW * 0.66)} cy={spineY - 20} r={10} fill="white" />
                        <circle cx={dynamicHeadX + (headW * 0.66)} cy={spineY - 20} r={4} fill="black" />
                        <foreignObject x={dynamicHeadX - 30} y={spineY - (headH * 0.8)} width={headW + 20} height={headH * 1.6} style={{pointerEvents: 'none'}}>
                            <div className="flex items-center justify-center h-full px-4 text-center">
                                <span className="text-white font-bold leading-tight drop-shadow-md" style={{fontSize: `${problemFontSize}px`}}>{problem}</span>
                            </div>
                        </foreignObject>
                    </g>
                );

                let currentX = firstBoneX;

                categoriesWithLayout.forEach((cat, index) => {
                    const { isTop, boneLength, causes } = cat;
                    const endY = isTop ? spineY - boneLength : spineY + boneLength;
                    const boneEndX = currentX - (boneLength * 0.45); 

                    elements.push(
                        <g key={`cat-${index}`}>
                            <line x1={currentX} y1={spineY} x2={boneEndX} y2={endY} stroke="#64748b" strokeWidth={4 * s} strokeLinecap="round" />
                            <g transform={`translate(${boneEndX}, ${isTop ? endY - 40 : endY + 20})`}>
                                <rect x={-70} y={-10} width={140} height={34} rx={17} fill="white" stroke="#cbd5e1" strokeWidth="1" className="drop-shadow-sm" />
                                <text x="0" y={13} textAnchor="middle" fontWeight="bold" fill="#1e293b" fontSize={fontSize}>{cat.name}</text>
                            </g>
                        </g>
                    );

                    let distFromSpine = 70 * s;

                    causes.forEach((causeGroup, cIndex) => {
                        const totalDist = Math.sqrt(Math.pow(boneEndX - currentX, 2) + Math.pow(endY - spineY, 2));
                        const t = distFromSpine / totalDist;
                        const rootX = currentX + (boneEndX - currentX) * t;
                        const rootY = spineY + (endY - spineY) * t;
                        const causeLen = Math.max(160 * s, causeGroup.totalLen);
                        const causeEndX = rootX + causeLen; 
                        const causeEndY = rootY;

                        elements.push(
                            <g key={`cause-${index}-${cIndex}`}>
                                <line x1={rootX} y1={rootY} x2={causeEndX} y2={causeEndY} stroke="#94a3b8" strokeWidth={3*s} strokeLinecap="round" />
                                <text x={causeEndX + 8} y={causeEndY + 5} fontSize={fontSize} fontWeight="bold" fill="#334155" textAnchor="start">{causeGroup.name}</text>
                            </g>
                        );

                        causeGroup.factors.forEach((factor, fIndex) => {
                            const factorRootX = rootX + factor.xOffset;
                            const factorRootY = rootY;
                            const isUpFactor = fIndex % 2 === 0;
                            const branchLen = 30 * s; 
                            const branchEndY = factorRootY + (isUpFactor ? -branchLen : branchLen);
                            const branchEndX = factorRootX + (15 * s); 
                            const statusConfig = STATUS_OPTIONS[factor.status] || STATUS_OPTIONS.ON_GOING;
                            const isExclude = factor.status === 'EXCLUDE';
                            const isPriority = factor.isPriority === true;
                            const strokeColor = isPriority ? '#ea580c' : statusConfig.boneColor;
                            const strokeWidth = isPriority ? 2.5 : 1.5;
                            const textColor = isPriority ? '#c2410c' : (isExclude ? '#cbd5e1' : '#1e293b');
                            const fontWeight = isPriority ? 'bold' : 'normal';
                            const textY = isUpFactor ? branchEndY - 5 : branchEndY + 14;

                            elements.push(
                                <g key={`fact-${factor.id}`}>
                                    <circle cx={factorRootX} cy={factorRootY} r={2*s} fill="#cbd5e1" />
                                    <line x1={factorRootX} y1={factorRootY} x2={branchEndX} y2={branchEndY} stroke={strokeColor} strokeWidth={strokeWidth} />
                                    <text x={branchEndX - 5} y={textY} fontSize={smallFontSize} fill={textColor} fontWeight={fontWeight} textDecoration={isExclude ? 'line-through' : 'none'} textAnchor="start">
                                        {statusConfig.icon} {factor.factor} {isPriority ? "⭐" : ""}
                                    </text>
                                </g>
                            );
                        });
                        distFromSpine += verticalBranchGap; 
                    });
                    currentX -= categorySpacing;
                });

                return { elements, totalWidth: Math.max(1200, requiredWidth), totalHeight: Math.max(750, dynamicTotalHeight), viewportY: 0 };
            }, [fishboneStructure, layoutConfig, problem]);

            useEffect(() => {
                const canvasEl = canvasRef.current;
                if (!canvasEl) return;
                const onWheel = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    setScale(s => Math.min(Math.max(0.3, s * delta), 3));
                };
                canvasEl.addEventListener('wheel', onWheel, { passive: false });
                return () => { canvasEl.removeEventListener('wheel', onWheel); };
            }, []);

            return (
                <div className="min-h-screen bg-slate-50 flex flex-col text-slate-800 font-sans print:bg-white">
                    <header className="bg-white border-b border-slate-200 px-6 py-3 flex justify-between items-center sticky top-0 z-50 print:hidden">
                        <div className="flex items-center gap-3">
                            <div className="bg-slate-900 text-white p-1.5 rounded-lg"><Maximize size={20} /></div>
                            <div><h1 className="font-bold text-lg leading-tight">Fishbone Pro</h1><p className="text-xs text-slate-500">RCA Edition</p></div>
                        </div>
                        <div className="flex gap-4 items-center">
                            <div className={`flex items-center gap-1.5 text-xs font-bold px-3 py-1.5 rounded-full transition-all duration-300 ${isAutoSaved ? 'opacity-100 bg-green-100 text-green-700 scale-105' : 'opacity-0 scale-95'}`}>
                                <Check size={14} />
                                Auto-saved
                            </div>
                            <div className="h-6 w-px bg-slate-200"></div>
                            <input type="file" ref={fileInputRef} onChange={handleLoad} accept=".json" className="hidden" />
                            <button onClick={() => fileInputRef.current?.click()} className="flex items-center gap-2 px-3 py-1.5 bg-white border border-slate-300 rounded-md text-sm font-medium hover:bg-slate-50 transition"><FolderOpen size={16} /> Open</button>
                            <button onClick={handleSave} className="flex items-center gap-2 px-3 py-1.5 bg-white border border-slate-300 rounded-md text-sm font-medium hover:bg-slate-50 transition"><Save size={16} /> Download</button>
                            <button onClick={handlePrint} className="flex items-center gap-2 px-4 py-1.5 bg-blue-600 text-white rounded-md text-sm font-medium hover:bg-blue-700 shadow-sm transition"><Printer size={16} /> Print / PDF</button>
                        </div>
                    </header>

                    <div className="flex-1 flex flex-col p-6 gap-6 max-w-[98%] mx-auto w-full print:p-0">
                        <div className="bg-white rounded-xl border border-slate-200 shadow-sm p-5 flex flex-col justify-center gap-3 print:hidden">
                            <div className="w-full">
                                <label className="text-xs font-bold text-slate-400 uppercase mb-1 block">Problem Title (Main Effect)</label>
                                <input type="text" value={problem} onChange={(e) => setProblem(e.target.value)} className="w-full bg-transparent font-bold text-slate-800 text-2xl outline-none border-b border-transparent focus:border-blue-500 transition-colors placeholder-slate-300" placeholder="Enter the main problem here..."/>
                            </div>
                            <div className="w-full">
                                <label className="text-xs font-bold text-slate-400 uppercase mb-1 block">Description / Context</label>
                                <textarea value={problemDesc} onChange={(e) => setProblemDesc(e.target.value)} className="w-full bg-slate-50 rounded-lg p-2 text-sm text-slate-600 outline-none border border-slate-200 focus:border-blue-400 transition-colors resize-none" rows={2} placeholder="Detailed description of the problem..."/>
                            </div>
                        </div>

                        <div className="bg-white rounded-2xl border border-slate-200 shadow-sm overflow-hidden relative print:border-none print:shadow-none" style={{height: '550px'}}>
                            <div className="absolute top-4 left-4 z-10 bg-white/90 p-2 rounded-lg border border-slate-200 shadow-sm backdrop-blur flex items-center gap-3 print:hidden">
                                <Type size={16} className="text-slate-500"/>
                                <div className="flex flex-col">
                                    <span className="text-[10px] font-bold text-slate-400 uppercase leading-none mb-1">Font Size</span>
                                    <div className="flex items-center gap-2">
                                        <input type="range" min="12" max="60" step="1" value={baseFontSize} onChange={(e) => setBaseFontSize(Number(e.target.value))} className="w-24 accent-blue-600 h-1.5"/>
                                        <span className="text-xs font-mono w-4 text-slate-600">{baseFontSize}</span>
                                    </div>
                                </div>
                            </div>
                            <div className="absolute bottom-4 right-4 z-10 flex gap-2 print:hidden">
                                <button onClick={() => {setScale(1); setPan({x:0,y:0})}} className="p-2 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 shadow-sm text-xs font-bold text-slate-600">Reset View</button>
                            </div>
                            
                            <div ref={canvasRef} className={`w-full h-full bg-slate-50 cursor-grab active:cursor-grabbing print:bg-white ${isDragging ? 'cursor-grabbing' : ''}`}
                                onMouseDown={(e) => { if(e.button===0) { setIsDragging(true); setDragStart({x: e.clientX-pan.x, y: e.clientY-pan.y}) }}}
                                onMouseMove={(e) => { if(isDragging) setPan({x: e.clientX-dragStart.x, y: e.clientY-dragStart.y}) }}
                                onMouseUp={() => setIsDragging(false)} onMouseLeave={() => setIsDragging(false)}>
                                {/* Updated viewBox to use dynamic Height */}
                                <svg width="100%" height="100%" viewBox={`${-pan.x} ${-pan.y} ${totalWidth} ${totalHeight}`} style={{transform: `scale(${scale})`, transformOrigin: '0 0', transition: isDragging ? 'none' : 'transform 0.1s ease-out'}}>
                                    <defs><pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse"><path d="M 40 0 L 0 0 0 40" fill="none" stroke="#e2e8f0" strokeWidth="1"/></pattern></defs>
                                    <rect x={-5000} y={-5000} width="10000" height="10000" fill="url(#grid)" className="print:hidden" />
                                    {fishboneElements}
                                </svg>
                            </div>
                        </div>

                        <div className="bg-white rounded-2xl border border-slate-200 shadow-sm p-6 print:border-none print:shadow-none print:p-0">
                            <div className="flex justify-between items-center mb-4 print:hidden">
                                <h2 className="text-lg font-bold flex items-center gap-2"><FileText size={20} className="text-blue-600"/>Hypothesis Verification</h2>
                                <div className="flex gap-2">
                                    {rows.length === 0 && <button onClick={addFirstRow} className="px-3 py-1.5 bg-blue-50 text-blue-600 rounded-md text-sm font-medium hover:bg-blue-100 flex items-center gap-1"><Plus size={16}/> Add First Row</button>}
                                    <button onClick={clearData} className="px-3 py-1.5 text-slate-400 hover:text-red-500 hover:bg-red-50 rounded-md text-sm transition flex items-center gap-1"><Trash2 size={16}/> Clear / Reset</button>
                                </div>
                            </div>
                            <div className="overflow-x-auto">
                                <table className="w-full text-left text-sm border-collapse min-w-[1200px]">
                                    <thead>
                                        <tr className="border-b border-slate-200 text-slate-500 text-xs uppercase tracking-wider">
                                            <th className="py-3 px-2 w-[4%] text-center">Priority</th>
                                            <th className="py-3 px-2 w-[10%]">Primary Bone (Category)</th>
                                            <th className="py-3 px-2 w-[12%]">Secondary Bone (Cause)</th>
                                            <th className="py-3 px-2 w-[15%] text-blue-700">Specific Factor (Hypothesis)</th>
                                            <th className="py-3 px-2 w-[22%]">Verification Method</th>
                                            <th className="py-3 px-2 w-[22%]">Evidence / Result</th>
                                            <th className="py-3 px-2 w-[10%]">Status</th>
                                            <th className="py-3 px-2 w-[5%] text-right print:hidden"></th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-slate-100">
                                        {rows.map((row, index) => (
                                            <tr key={row.id} className="group hover:bg-slate-50 transition-colors">
                                                <td className="p-2 align-top text-center">
                                                    <button onClick={() => handleRowChange(row.id, 'isPriority', !row.isPriority)} className="p-1.5 hover:bg-orange-50 rounded-full transition">
                                                        <Star size={18} filled={row.isPriority} />
                                                    </button>
                                                </td>
                                                <td className="p-2 align-top"><input type="text" value={row.category} onChange={e => handleRowChange(row.id, 'category', e.target.value)} className="w-full bg-transparent font-bold text-slate-700 outline-none border-b border-transparent focus:border-blue-400 px-1 py-1" placeholder="Category" /></td>
                                                <td className="p-2 align-top"><input type="text" value={row.cause} onChange={e => handleRowChange(row.id, 'cause', e.target.value)} className="w-full bg-transparent text-slate-700 outline-none border-b border-transparent focus:border-blue-400 px-1 py-1" placeholder="Cause" /></td>
                                                <td className="p-2 align-top bg-blue-50/30 rounded"><input type="text" value={row.factor} onChange={e => handleRowChange(row.id, 'factor', e.target.value)} className="w-full bg-transparent font-medium text-blue-900 outline-none border-b border-transparent focus:border-blue-400 px-1 py-1" placeholder="Hypothesis" /></td>
                                                <td className="p-2 align-top"><HoverTextarea value={row.method} onChange={e => handleRowChange(row.id, 'method', e.target.value)} placeholder="Method"/></td>
                                                <td className="p-2 align-top"><HoverTextarea value={row.evidence} onChange={e => handleRowChange(row.id, 'evidence', e.target.value)} placeholder="Result"/></td>
                                                <td className="p-2 align-top">
                                                    <select value={row.status} onChange={e => handleRowChange(row.id, 'status', e.target.value)} className={`w-full text-xs font-bold rounded-md px-2 py-1.5 border-none outline-none cursor-pointer appearance-none ${STATUS_OPTIONS[row.status]?.bg || 'bg-gray-100'}`}>
                                                        {Object.values(STATUS_OPTIONS).map(opt => <option key={opt.id} value={opt.id}>{opt.label}</option>)}
                                                    </select>
                                                </td>
                                                <td className="p-2 text-right print:hidden">
                                                    <div className="flex justify-end gap-1">
                                                        <button onClick={() => insertRowAfter(index)} className="p-1.5 text-blue-600 hover:bg-blue-50 rounded" title="Insert Below"><Plus size={16}/></button>
                                                        <button onClick={() => deleteRow(row.id)} className="p-1.5 text-red-500 hover:bg-red-50 rounded" title="Delete"><Trash2 size={16}/></button>
                                                    </div>
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            </div>
                            <RichTextEditor value={notes} onChange={setNotes} />
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
